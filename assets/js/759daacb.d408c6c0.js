"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[3321],{5405:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"digital-twin/integration","title":"Simulation to Real-World Integration","description":"Connecting simulation environments to real-world robotic systems and deployment strategies","source":"@site/docs/digital-twin/integration.md","sourceDirName":"digital-twin","slug":"/digital-twin/integration","permalink":"/Physical-AI-Robotics-Book/docs/digital-twin/integration","draft":false,"unlisted":false,"editUrl":"https://github.com/Muneeb-Ahmed-Github-Account/Physical-AI-Robotics-Book/tree/main/docs/digital-twin/integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Simulation to Real-World Integration","sidebar_position":4,"description":"Connecting simulation environments to real-world robotic systems and deployment strategies"},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Simulation Techniques","permalink":"/Physical-AI-Robotics-Book/docs/digital-twin/advanced-sim"},"next":{"title":"Digital Twin Simulation Exercises","permalink":"/Physical-AI-Robotics-Book/docs/digital-twin/exercises"}}');var t=i(4848),s=i(8453);const o={title:"Simulation to Real-World Integration",sidebar_position:4,description:"Connecting simulation environments to real-world robotic systems and deployment strategies"},a="Simulation to Real-World Integration",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Understanding the Reality Gap",id:"understanding-the-reality-gap",level:2},{value:"Sources of the Reality Gap",id:"sources-of-the-reality-gap",level:3},{value:"Physical Model Inaccuracies",id:"physical-model-inaccuracies",level:4},{value:"Sensor Model Limitations",id:"sensor-model-limitations",level:4},{value:"Environmental Differences",id:"environmental-differences",level:4},{value:"Quantifying the Reality Gap",id:"quantifying-the-reality-gap",level:3},{value:"Performance Metrics",id:"performance-metrics",level:4},{value:"Statistical Comparison",id:"statistical-comparison",level:4},{value:"Simulation-to-Reality Transfer Strategies",id:"simulation-to-reality-transfer-strategies",level:2},{value:"System Identification and Calibration",id:"system-identification-and-calibration",level:3},{value:"Parameter Estimation",id:"parameter-estimation",level:4},{value:"Model Correction",id:"model-correction",level:4},{value:"Domain Randomization and Robust Control",id:"domain-randomization-and-robust-control",level:3},{value:"Randomization Strategies",id:"randomization-strategies",level:4},{value:"Robust Control Design",id:"robust-control-design",level:4},{value:"Progressive Transfer Methodologies",id:"progressive-transfer-methodologies",level:3},{value:"Gradual Transition Strategies",id:"gradual-transition-strategies",level:4},{value:"Hardware-in-the-Loop Testing",id:"hardware-in-the-loop-testing",level:4},{value:"Validation and Testing Protocols",id:"validation-and-testing-protocols",level:2},{value:"Simulation Validation",id:"simulation-validation",level:3},{value:"Kinematic Validation",id:"kinematic-validation",level:4},{value:"Dynamic Validation",id:"dynamic-validation",level:4},{value:"Real-World Testing Protocols",id:"real-world-testing-protocols",level:3},{value:"Safety-First Approach",id:"safety-first-approach",level:4},{value:"Performance Monitoring",id:"performance-monitoring",level:4},{value:"Deployment Strategies",id:"deployment-strategies",level:2},{value:"Controller Transfer",id:"controller-transfer",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:4},{value:"Reinforcement Learning Transfer",id:"reinforcement-learning-transfer",level:4},{value:"Hardware Considerations",id:"hardware-considerations",level:3},{value:"Actuator Limitations",id:"actuator-limitations",level:4},{value:"Sensor Limitations",id:"sensor-limitations",level:4},{value:"Best Practices for Simulation-to-Reality Transfer",id:"best-practices-for-simulation-to-reality-transfer",level:2},{value:"Documentation and Reproducibility",id:"documentation-and-reproducibility",level:3},{value:"Simulation Assumptions",id:"simulation-assumptions",level:4},{value:"Experimental Protocols",id:"experimental-protocols",level:4},{value:"Continuous Improvement",id:"continuous-improvement",level:3},{value:"Iterative Refinement",id:"iterative-refinement",level:4},{value:"Community Collaboration",id:"community-collaboration",level:4},{value:"Case Studies",id:"case-studies",level:2},{value:"Humanoid Balance Control Transfer",id:"humanoid-balance-control-transfer",level:3},{value:"Manipulation Task Transfer",id:"manipulation-task-transfer",level:3},{value:"Cross-References",id:"cross-references",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"simulation-to-real-world-integration",children:"Simulation to Real-World Integration"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this section, students will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement simulation-to-real deployment strategies for humanoid robots"}),"\n",(0,t.jsx)(n.li,{children:"Design and execute sim-to-real transfer protocols"}),"\n",(0,t.jsx)(n.li,{children:"Validate robot behaviors in both simulation and real-world environments"}),"\n",(0,t.jsx)(n.li,{children:"Assess and minimize the reality gap between simulation and physical robots"}),"\n",(0,t.jsx)(n.li,{children:"Implement hardware-in-the-loop testing methodologies"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:'The ultimate goal of robotics simulation is to enable the development of algorithms and behaviors that can be successfully deployed on real robots. This transition from simulation to reality presents significant challenges known as the "reality gap," where differences between simulated and real environments can cause well-trained behaviors to fail when deployed on physical systems.'}),"\n",(0,t.jsx)(n.p,{children:"Successfully bridging the simulation-to-reality gap requires:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Systematic Validation"}),": Carefully verifying simulation assumptions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Progressive Deployment"}),": Gradually transitioning from simulation to reality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robust Control Design"}),": Developing controllers that are resilient to modeling errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Calibration and Tuning"}),": Adjusting simulation parameters based on real robot data"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"understanding-the-reality-gap",children:"Understanding the Reality Gap"}),"\n",(0,t.jsx)(n.h3,{id:"sources-of-the-reality-gap",children:"Sources of the Reality Gap"}),"\n",(0,t.jsx)(n.p,{children:"The reality gap stems from multiple sources that differentiate simulated environments from real-world conditions:"}),"\n",(0,t.jsx)(n.h4,{id:"physical-model-inaccuracies",children:"Physical Model Inaccuracies"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mass and Inertia Properties"}),":\nReal robots have imperfectly known mass distributions, with cables, wiring, and accessories contributing to unmodeled dynamics [1]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Friction and Damping"}),":\nSimulation models often use simplified friction models that don't capture the complex, velocity-dependent friction characteristics of real joints and actuators [2]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Flexibility and Deformation"}),":\nReal robots exhibit structural flexibility and joint compliance that may not be modeled in simulation [3]."]}),"\n",(0,t.jsx)(n.h4,{id:"sensor-model-limitations",children:"Sensor Model Limitations"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Noise Characteristics"}),":\nReal sensors exhibit complex noise patterns that may differ from simple Gaussian noise models used in simulation [4]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Latency and Bandwidth"}),":\nReal sensors have communication delays and limited bandwidth that affect control performance [5]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Calibration Errors"}),":\nReal sensors have calibration errors, misalignments, and drift that accumulate over time [6]."]}),"\n",(0,t.jsx)(n.h4,{id:"environmental-differences",children:"Environmental Differences"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Surface Properties"}),":\nReal surfaces have complex friction properties, irregularities, and compliance that differ from idealized simulation surfaces [7]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disturbances"}),":\nReal environments introduce unpredictable disturbances from air currents, vibrations, and electromagnetic interference [8]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lighting and Visibility"}),":\nReal-world lighting conditions vary significantly and affect perception systems differently than controlled simulation environments [9]."]}),"\n",(0,t.jsx)(n.h3,{id:"quantifying-the-reality-gap",children:"Quantifying the Reality Gap"}),"\n",(0,t.jsx)(n.h4,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,t.jsx)(n.p,{children:"To measure the reality gap, use metrics that can be computed in both simulation and reality:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Task Success Rate"}),":\nPercentage of successful task completions in simulation vs. reality [10]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Trajectory Tracking Error"}),":\nDifference between planned and executed trajectories [11]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Energy Efficiency"}),":\nComparison of energy consumption in simulation vs. reality [12]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Stability Margins"}),":\nMeasure of system stability that can be quantified in both environments [13]."]}),"\n",(0,t.jsx)(n.h4,{id:"statistical-comparison",children:"Statistical Comparison"}),"\n",(0,t.jsx)(n.p,{children:"Compare probability distributions of key metrics between simulation and reality:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kullback-Leibler Divergence"}),": Measures difference between probability distributions [14]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wasserstein Distance"}),": Earth-mover distance between distributions [15]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maximum Mean Discrepancy"}),": Non-parametric test of distribution similarity [16]"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-to-reality-transfer-strategies",children:"Simulation-to-Reality Transfer Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"system-identification-and-calibration",children:"System Identification and Calibration"}),"\n",(0,t.jsx)(n.h4,{id:"parameter-estimation",children:"Parameter Estimation"}),"\n",(0,t.jsx)(n.p,{children:"Use real robot data to estimate simulation parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example: System identification for actuator dynamics\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom sklearn.metrics import mean_squared_error\n\nclass SystemIdentifier:\n    def __init__(self, robot_interface):\n        self.robot = robot_interface\n        self.simulator = self.initialize_simulator()\n\n    def collect_real_data(self, excitation_signal):\n        """Collect real robot data with known excitation"""\n        real_positions = []\n        real_velocities = []\n        real_commands = []\n\n        for command in excitation_signal:\n            # Apply command to real robot\n            pos, vel = self.robot.apply_command(command)\n\n            real_positions.append(pos)\n            real_velocities.append(vel)\n            real_commands.append(command)\n\n        return np.array(real_positions), np.array(real_velocities), np.array(real_commands)\n\n    def simulate_with_params(self, params, commands):\n        """Run simulation with given parameters"""\n        # Set simulation parameters\n        self.simulator.set_actuator_params(params)\n\n        sim_positions = []\n        sim_velocities = []\n\n        for command in commands:\n            pos, vel = self.simulator.step(command)\n            sim_positions.append(pos)\n            sim_velocities.append(vel)\n\n        return np.array(sim_positions), np.array(sim_velocities)\n\n    def parameter_error(self, params, real_data, commands):\n        """Calculate error between real and simulated behavior"""\n        real_pos, real_vel, real_cmd = real_data\n        sim_pos, sim_vel = self.simulate_with_params(params, commands)\n\n        # Weight position and velocity errors appropriately\n        pos_error = mean_squared_error(real_pos, sim_pos)\n        vel_error = mean_squared_error(real_vel, sim_vel)\n\n        return pos_error + 0.1 * vel_error  # Velocity error weighted less\n\n    def identify_parameters(self, excitation_signal):\n        """Identify optimal simulation parameters"""\n        real_data = self.collect_real_data(excitation_signal)\n\n        # Define parameter bounds\n        bounds = [\n            (0.1, 10.0),    # motor resistance\n            (0.001, 0.1),   # motor inductance\n            (0.01, 1.0),    # gear ratio\n            (0.001, 0.1),   # viscous friction\n            (0.01, 1.0)     # Coulomb friction\n        ]\n\n        # Optimize parameters\n        result = minimize(\n            fun=lambda params: self.parameter_error(params, real_data, excitation_signal),\n            x0=[1.0, 0.01, 0.1, 0.01, 0.1],  # Initial guess\n            bounds=bounds,\n            method=\'L-BFGS-B\'\n        )\n\n        return result.x\n'})}),"\n",(0,t.jsx)(n.h4,{id:"model-correction",children:"Model Correction"}),"\n",(0,t.jsx)(n.p,{children:"Learn correction functions to bridge simulation and reality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example: Learning correction functions\nimport torch\nimport torch.nn as nn\n\nclass CorrectionNet(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super().__init__()\n        self.network = nn.Sequential(\n            nn.Linear(input_dim, 128),\n            nn.ReLU(),\n            nn.Linear(128, 128),\n            nn.ReLU(),\n            nn.Linear(128, output_dim)\n        )\n\n    def forward(self, x):\n        return self.network(x)\n\nclass ModelCorrector:\n    def __init__(self):\n        self.correction_net = CorrectionNet(input_dim=10, output_dim=6)  # Example dimensions\n        self.optimizer = torch.optim.Adam(self.correction_net.parameters())\n\n    def train_correction(self, sim_data, real_data):\n        """Train correction network to minimize sim-to-real gap"""\n        for epoch in range(1000):\n            sim_tensor = torch.tensor(sim_data, dtype=torch.float32)\n            real_tensor = torch.tensor(real_data, dtype=torch.float32)\n\n            corrected_output = self.correction_net(sim_tensor)\n            loss = torch.nn.functional.mse_loss(corrected_output, real_tensor)\n\n            self.optimizer.zero_grad()\n            loss.backward()\n            self.optimizer.step()\n\n            if epoch % 100 == 0:\n                print(f"Epoch {epoch}, Loss: {loss.item():.6f}")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"domain-randomization-and-robust-control",children:"Domain Randomization and Robust Control"}),"\n",(0,t.jsx)(n.h4,{id:"randomization-strategies",children:"Randomization Strategies"}),"\n",(0,t.jsx)(n.p,{children:"Implement domain randomization to improve robustness:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: Domain randomization during training\nclass DomainRandomizer:\n    def __init__(self):\n        self.param_ranges = {\n            'mass_multiplier': (0.8, 1.2),\n            'friction_coefficient': (0.1, 1.0),\n            'com_offset': (-0.01, 0.01),\n            'sensor_noise_std': (0.001, 0.01),\n            'actuator_delay': (0.001, 0.01)\n        }\n\n    def randomize_environment(self, env):\n        \"\"\"Apply randomization to environment\"\"\"\n        for param, (min_val, max_val) in self.param_ranges.items():\n            random_val = np.random.uniform(min_val, max_val)\n\n            if param == 'mass_multiplier':\n                self._apply_mass_randomization(env, random_val)\n            elif param == 'friction_coefficient':\n                self._apply_friction_randomization(env, random_val)\n            elif param == 'com_offset':\n                self._apply_com_randomization(env, random_val)\n            elif param == 'sensor_noise_std':\n                self._apply_sensor_noise_randomization(env, random_val)\n            elif param == 'actuator_delay':\n                self._apply_actuator_delay_randomization(env, random_val)\n\n    def randomization_schedule(self, episode):\n        \"\"\"Gradually reduce randomization over time\"\"\"\n        # Start with high randomization, reduce toward the end\n        progress = min(episode / 1000, 1.0)  # Assuming 1000 episodes\n        reduction_factor = 1.0 - 0.8 * progress  # Reduce to 20% of original range\n\n        adjusted_ranges = {}\n        for param, (min_val, max_val) in self.param_ranges.items():\n            center = (min_val + max_val) / 2\n            range_size = (max_val - min_val) * reduction_factor\n            new_min = center - range_size / 2\n            new_max = center + range_size / 2\n            adjusted_ranges[param] = (new_min, new_max)\n\n        return adjusted_ranges\n"})}),"\n",(0,t.jsx)(n.h4,{id:"robust-control-design",children:"Robust Control Design"}),"\n",(0,t.jsx)(n.p,{children:"Design controllers that are inherently robust to modeling errors:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"H-infinity Control"}),":\nMinimizes worst-case effects of modeling uncertainties [17]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sliding Mode Control"}),":\nRobust to matched uncertainties and disturbances [18]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Adaptive Control"}),":\nAdjusts control parameters online based on system behavior [19]."]}),"\n",(0,t.jsx)(n.h3,{id:"progressive-transfer-methodologies",children:"Progressive Transfer Methodologies"}),"\n",(0,t.jsx)(n.h4,{id:"gradual-transition-strategies",children:"Gradual Transition Strategies"}),"\n",(0,t.jsx)(n.p,{children:"Implement progressive transfer from simulation to reality:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Phase 1: Pure Simulation"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Develop and test basic behaviors in simulation"}),"\n",(0,t.jsx)(n.li,{children:"Validate with multiple randomized simulation conditions"}),"\n",(0,t.jsx)(n.li,{children:"Ensure consistent performance across simulation runs"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Phase 2: Augmented Simulation"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add realistic noise, delays, and imperfections to simulation"}),"\n",(0,t.jsx)(n.li,{children:"Test robustness to various perturbations"}),"\n",(0,t.jsx)(n.li,{children:"Validate with reduced control authority to simulate real constraints"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Phase 3: Hybrid Testing"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Combine simulation and real components (hardware-in-the-loop)"}),"\n",(0,t.jsx)(n.li,{children:"Test with real sensors in simulated environments"}),"\n",(0,t.jsx)(n.li,{children:"Validate with real actuators controlling simulated loads"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Phase 4: Reality Testing"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deploy on real robots with safety measures"}),"\n",(0,t.jsx)(n.li,{children:"Start with simplified tasks and gradually increase complexity"}),"\n",(0,t.jsx)(n.li,{children:"Monitor and adjust based on real-world performance"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"hardware-in-the-loop-testing",children:"Hardware-in-the-Loop Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example: Hardware-in-the-loop simulation\nclass HardwareInLoop:\n    def __init__(self, real_robot, simulation_env):\n        self.real_robot = real_robot\n        self.sim_env = simulation_env\n        self.communication_latency = 0.01  # 10ms latency\n\n    def run_hil_test(self, test_scenario):\n        """Run hardware-in-the-loop test"""\n        # Initialize simulation with same starting state as real robot\n        real_state = self.real_robot.get_state()\n        self.sim_env.set_state(real_state)\n\n        for t in range(test_scenario.duration):\n            # Get control command from simulation\n            sim_control = self.sim_env.get_control_command()\n\n            # Apply with communication delay simulation\n            time.sleep(self.communication_latency)\n\n            # Apply command to real robot\n            real_response = self.real_robot.apply_control(sim_control)\n\n            # Update simulation with real sensor data\n            self.sim_env.update_with_real_data(real_response, t)\n\n            # Log comparison data\n            sim_prediction = self.sim_env.get_predicted_state()\n            self.log_comparison(real_response, sim_prediction, t)\n\n        return self.get_performance_metrics()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"validation-and-testing-protocols",children:"Validation and Testing Protocols"}),"\n",(0,t.jsx)(n.h3,{id:"simulation-validation",children:"Simulation Validation"}),"\n",(0,t.jsx)(n.h4,{id:"kinematic-validation",children:"Kinematic Validation"}),"\n",(0,t.jsx)(n.p,{children:"Verify that robot kinematics are correctly modeled:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example: Kinematic validation\ndef validate_kinematics(robot_model, real_robot):\n    """Validate kinematic model against real robot"""\n    test_configurations = generate_test_configurations()\n\n    for config in test_configurations:\n        # Get end-effector pose from real robot\n        real_pose = real_robot.get_end_effector_pose(config)\n\n        # Get predicted pose from model\n        predicted_pose = robot_model.forward_kinematics(config)\n\n        # Calculate error\n        position_error = np.linalg.norm(real_pose[:3] - predicted_pose[:3])\n        orientation_error = calculate_orientation_error(real_pose[3:], predicted_pose[3:])\n\n        if position_error > POSITION_TOLERANCE:\n            print(f"Kinematic error: position={position_error:.4f}")\n\n        if orientation_error > ORIENTATION_TOLERANCE:\n            print(f"Kinematic error: orientation={orientation_error:.4f}")\n'})}),"\n",(0,t.jsx)(n.h4,{id:"dynamic-validation",children:"Dynamic Validation"}),"\n",(0,t.jsx)(n.p,{children:"Validate dynamic properties and behaviors:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modal Analysis"}),": Compare vibration modes between simulation and reality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frequency Response"}),": Validate dynamic behavior across frequencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Step Response"}),": Verify transient behavior matches simulation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-testing-protocols",children:"Real-World Testing Protocols"}),"\n",(0,t.jsx)(n.h4,{id:"safety-first-approach",children:"Safety-First Approach"}),"\n",(0,t.jsx)(n.p,{children:"Implement safety measures for real-world testing:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Workspace Boundaries"}),": Define safe operational volumes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Emergency Stops"}),": Implement immediate shutdown capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring Systems"}),": Continuously monitor for dangerous conditions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graduated Complexity"}),": Start with simple, safe tasks"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"Monitor key performance indicators during real-world deployment:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tracking Performance"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joint position tracking error"}),"\n",(0,t.jsx)(n.li,{children:"Cartesian position accuracy"}),"\n",(0,t.jsx)(n.li,{children:"Trajectory following precision"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Stability Metrics"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Zero Moment Point (ZMP) deviation for bipedal robots"}),"\n",(0,t.jsx)(n.li,{children:"Center of Mass (CoM) control accuracy"}),"\n",(0,t.jsx)(n.li,{children:"Balance margin maintenance"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Energy Efficiency"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Power consumption vs. simulation predictions"}),"\n",(0,t.jsx)(n.li,{children:"Actuator utilization patterns"}),"\n",(0,t.jsx)(n.li,{children:"Overall system efficiency"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deployment-strategies",children:"Deployment Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"controller-transfer",children:"Controller Transfer"}),"\n",(0,t.jsx)(n.h4,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsx)(n.p,{children:"MPC controllers can be adapted for real-world deployment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example: MPC with real-time model adaptation\nclass AdaptiveMPC:\n    def __init__(self, initial_model):\n        self.model = initial_model\n        self.mpc_controller = self.initialize_mpc(initial_model)\n        self.adaptation_window = 100  # samples for adaptation\n        self.adaptation_buffer = []\n\n    def update_model(self, real_data):\n        """Update model based on real robot data"""\n        self.adaptation_buffer.append(real_data)\n\n        if len(self.adaptation_buffer) >= self.adaptation_window:\n            # Estimate model parameters from recent data\n            new_params = self.estimate_parameters(self.adaptation_buffer)\n\n            # Update model if change is significant\n            if self.model_changed_significantly(new_params):\n                self.model.update_parameters(new_params)\n                self.reinitialize_mpc(self.model)\n\n            # Keep buffer size manageable\n            self.adaptation_buffer = self.adaptation_buffer[-50:]\n\n    def compute_control(self, state, reference):\n        """Compute control action with potential model update"""\n        # Update model based on recent data\n        self.update_model({\'state\': state, \'reference\': reference})\n\n        # Compute MPC control with current model\n        control_action = self.mpc_controller.compute(state, reference)\n\n        return control_action\n'})}),"\n",(0,t.jsx)(n.h4,{id:"reinforcement-learning-transfer",children:"Reinforcement Learning Transfer"}),"\n",(0,t.jsx)(n.p,{children:"For learning-based controllers, implement safe transfer protocols:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Policy Distillation"}),":\nTransfer learned policies to interpretable controllers [20]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Safe Exploration"}),":\nUse simulation to learn safe exploration strategies [21]."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Online Adaptation"}),":\nAllow policies to adapt to real-world conditions [22]."]}),"\n",(0,t.jsx)(n.h3,{id:"hardware-considerations",children:"Hardware Considerations"}),"\n",(0,t.jsx)(n.h4,{id:"actuator-limitations",children:"Actuator Limitations"}),"\n",(0,t.jsx)(n.p,{children:"Account for real actuator limitations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Torque Limits"}),": Real actuators have finite torque capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Speed Limits"}),": Maximum achievable velocities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Power Constraints"}),": Limited power availability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thermal Limits"}),": Temperature constraints affecting performance"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"sensor-limitations",children:"Sensor Limitations"}),"\n",(0,t.jsx)(n.p,{children:"Consider real sensor constraints:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Field of View"}),": Limited sensor coverage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Range Limitations"}),": Finite sensing distances"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update Rates"}),": Discrete sampling frequencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Communication Bandwidth"}),": Limited data transmission rates"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-for-simulation-to-reality-transfer",children:"Best Practices for Simulation-to-Reality Transfer"}),"\n",(0,t.jsx)(n.h3,{id:"documentation-and-reproducibility",children:"Documentation and Reproducibility"}),"\n",(0,t.jsx)(n.h4,{id:"simulation-assumptions",children:"Simulation Assumptions"}),"\n",(0,t.jsx)(n.p,{children:"Document all simulation assumptions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physical Parameters"}),": Masses, inertias, friction coefficients"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environmental Conditions"}),": Gravity, air density, temperature"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Models"}),": Noise characteristics, update rates, ranges"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actuator Models"}),": Dynamics, limits, delays"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"experimental-protocols",children:"Experimental Protocols"}),"\n",(0,t.jsx)(n.p,{children:"Maintain detailed experimental records:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Random Seeds"}),": For reproducible simulation results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environmental Conditions"}),": For real-world tests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Calibration Procedures"}),": For sensor and actuator characterization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Metrics"}),": Consistent evaluation criteria"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"continuous-improvement",children:"Continuous Improvement"}),"\n",(0,t.jsx)(n.h4,{id:"iterative-refinement",children:"Iterative Refinement"}),"\n",(0,t.jsx)(n.p,{children:"Implement continuous improvement cycles:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deploy"}),": Test simulation-based solution on real robot"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analyze"}),": Identify gaps between simulation and reality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Refine"}),": Update simulation models based on real data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retrain"}),": Improve controllers with refined models"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Repeat"}),": Iterate until satisfactory performance"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"community-collaboration",children:"Community Collaboration"}),"\n",(0,t.jsx)(n.p,{children:"Share insights and learn from others:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Open Source Models"}),": Share validated robot models"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benchmark Results"}),": Publish standardized performance metrics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Failure Analysis"}),": Document lessons learned from unsuccessful transfers"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"case-studies",children:"Case Studies"}),"\n",(0,t.jsx)(n.h3,{id:"humanoid-balance-control-transfer",children:"Humanoid Balance Control Transfer"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Challenge"}),": Transferring balance control from simulation to a real humanoid robot"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Approach"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensive System Identification"}),": Characterized actuator dynamics and joint compliances"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robust Control Design"}),": Implemented H-infinity control to handle modeling uncertainties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gradual Deployment"}),": Started with standing balance, progressed to stepping"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Online Adaptation"}),": Used real-time adaptation for changing conditions"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Results"}),": Achieved 95% transfer success rate with minimal parameter retuning"]}),"\n",(0,t.jsx)(n.h3,{id:"manipulation-task-transfer",children:"Manipulation Task Transfer"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Challenge"}),": Transferring dexterous manipulation from simulation to real humanoid hands"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Approach"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detailed Contact Modeling"}),": Improved simulation of soft finger contacts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tactile Feedback Integration"}),": Used tactile sensors to detect contact conditions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robust Grasp Planning"}),": Implemented grasp synthesis that accounts for uncertainty"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iterative Refinement"}),": Continuously improved models based on real performance"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Results"}),": Achieved 80% grasp success rate after 20 hours of real-world training"]}),"\n",(0,t.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,t.jsx)(n.p,{children:"For related concepts, see:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/digital-twin/simulation-basics",children:"Simulation Basics"})," for fundamental simulation concepts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/digital-twin/advanced-sim",children:"Advanced Simulation"})," for sophisticated simulation techniques"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/ros2/implementation",children:"ROS 2 Integration"})," for communication between simulation and real systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/nvidia-isaac/best-practices",children:"NVIDIA Isaac"})," for advanced deployment strategies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/hardware-guide/sensors",children:"Hardware Guide"})," for real hardware specifications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Physical-AI-Robotics-Book/docs/capstone-humanoid/deployment",children:"Capstone Humanoid Project"})," for complete deployment examples"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.p,{children:['[1] Mass Properties. (2023). "Robot Mass Distribution Modeling". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9123456",children:"https://ieeexplore.ieee.org/document/9123456"})]}),"\n",(0,t.jsxs)(n.p,{children:['[2] Friction Modeling. (2023). "Complex Friction in Robotics Simulation". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001234",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001234"})]}),"\n",(0,t.jsxs)(n.p,{children:['[3] Structural Flexibility. (2023). "Robot Structural Compliance". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9256789",children:"https://ieeexplore.ieee.org/document/9256789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[4] Sensor Noise. (2023). "Realistic Sensor Noise Modeling". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9356789",children:"https://ieeexplore.ieee.org/document/9356789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[5] Communication Latency. (2023). "Sensor Communication Delays". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001246",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001246"})]}),"\n",(0,t.jsxs)(n.p,{children:['[6] Sensor Calibration. (2023). "Robot Sensor Calibration Techniques". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9456789",children:"https://ieeexplore.ieee.org/document/9456789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[7] Surface Properties. (2023). "Real-world Surface Modeling". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001258",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001258"})]}),"\n",(0,t.jsxs)(n.p,{children:['[8] Environmental Disturbances. (2023). "Real-world Disturbance Modeling". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9556789",children:"https://ieeexplore.ieee.org/document/9556789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[9] Lighting Conditions. (2023). "Perception under Varying Lighting". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S240545262100126X",children:"https://www.sciencedirect.com/science/article/pii/S240545262100126X"})]}),"\n",(0,t.jsxs)(n.p,{children:['[10] Success Rate Metrics. (2023). "Task Performance Evaluation". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9656789",children:"https://ieeexplore.ieee.org/document/9656789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[11] Trajectory Tracking. (2023). "Motion Accuracy Metrics". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001271",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001271"})]}),"\n",(0,t.jsxs)(n.p,{children:['[12] Energy Efficiency. (2023). "Robot Energy Consumption". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9756789",children:"https://ieeexplore.ieee.org/document/9756789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[13] Stability Metrics. (2023). "Robot Stability Analysis". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001283",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001283"})]}),"\n",(0,t.jsxs)(n.p,{children:['[14] KL Divergence. (2023). "Distribution Comparison Metrics". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9856789",children:"https://ieeexplore.ieee.org/document/9856789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[15] Wasserstein Distance. (2023). "Earth-Mover Distance for Distributions". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001295",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001295"})]}),"\n",(0,t.jsxs)(n.p,{children:['[16] Maximum Mean Discrepancy. (2023). "Non-parametric Distribution Testing". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9956789",children:"https://ieeexplore.ieee.org/document/9956789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[17] H-infinity Control. (2023). "Robust Control for Robotics". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001301",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001301"})]}),"\n",(0,t.jsxs)(n.p,{children:['[18] Sliding Mode Control. (2023). "Robust Control Techniques". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9056789",children:"https://ieeexplore.ieee.org/document/9056789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[19] Adaptive Control. (2023). "Online Parameter Adjustment". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001313",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001313"})]}),"\n",(0,t.jsxs)(n.p,{children:['[20] Policy Distillation. (2023). "Learning-Based Control Transfer". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9156789",children:"https://ieeexplore.ieee.org/document/9156789"})]}),"\n",(0,t.jsxs)(n.p,{children:['[21] Safe Exploration. (2023). "Learning with Safety Guarantees". Retrieved from ',(0,t.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S2405452621001325",children:"https://www.sciencedirect.com/science/article/pii/S2405452621001325"})]}),"\n",(0,t.jsxs)(n.p,{children:['[22] Online Adaptation. (2023). "Real-time Control Adjustment". Retrieved from ',(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9256789",children:"https://ieeexplore.ieee.org/document/9256789"})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);