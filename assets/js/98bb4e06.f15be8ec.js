"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[3631],{2966:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"ros2/theory","title":"ROS 2 Theory","description":"Theoretical foundations and core concepts of ROS 2 architecture","source":"@site/docs/ros2/theory.md","sourceDirName":"ros2","slug":"/ros2/theory","permalink":"/Physical-AI-Robotics-Book/docs/ros2/theory","draft":false,"unlisted":false,"editUrl":"https://github.com/Muneeb-Ahmed-Github-Account/Physical-AI-Robotics-Book/tree/main/docs/ros2/theory.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"ROS 2 Theory","sidebar_position":2,"description":"Theoretical foundations and core concepts of ROS 2 architecture"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Overview","permalink":"/Physical-AI-Robotics-Book/docs/ros2/overview"},"next":{"title":"ROS 2 Implementation","permalink":"/Physical-AI-Robotics-Book/docs/ros2/implementation"}}');var r=s(4848),t=s(8453);const o={title:"ROS 2 Theory",sidebar_position:2,description:"Theoretical foundations and core concepts of ROS 2 architecture"},l="ROS 2 Theory",c={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Client Library Layer",id:"client-library-layer",level:3},{value:"DDS Middleware",id:"dds-middleware",level:3},{value:"Domain IDs and Isolation",id:"domain-ids-and-isolation",level:3},{value:"Core Communication Patterns",id:"core-communication-patterns",level:2},{value:"Topics (Publish-Subscribe)",id:"topics-publish-subscribe",level:3},{value:"Services (Request-Response)",id:"services-request-response",level:3},{value:"Actions (Goal-Based Communication)",id:"actions-goal-based-communication",level:3},{value:"Quality of Service (QoS) Policies",id:"quality-of-service-qos-policies",level:2},{value:"Reliability Policy",id:"reliability-policy",level:3},{value:"Durability Policy",id:"durability-policy",level:3},{value:"History Policy",id:"history-policy",level:3},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:2},{value:"Parameters and Configuration",id:"parameters-and-configuration",level:2},{value:"Namespaces and Naming",id:"namespaces-and-naming",level:2},{value:"Time and Time Sources",id:"time-and-time-sources",level:2},{value:"Memory Management and Performance",id:"memory-management-and-performance",level:2},{value:"Security Architecture",id:"security-architecture",level:2},{value:"Integration with Real-time Systems",id:"integration-with-real-time-systems",level:2},{value:"References",id:"references",level:2},{value:"Cross-References",id:"cross-references",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"ros-2-theory",children:"ROS 2 Theory"})}),"\n",(0,r.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(i.p,{children:"After completing this section, students will be able to:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Describe the layered architecture of ROS 2 and the role of client libraries"}),"\n",(0,r.jsx)(i.li,{children:"Explain the Quality of Service (QoS) policies and their impact on communication"}),"\n",(0,r.jsx)(i.li,{children:"Understand the concept of Domain IDs and their use in system isolation"}),"\n",(0,r.jsx)(i.li,{children:"Identify the different communication patterns (topics, services, actions) and their appropriate use cases"}),"\n",(0,r.jsx)(i.li,{children:"Explain the lifecycle node concept and its importance in humanoid robotics"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 architecture is fundamentally different from its predecessor, designed with distributed systems, real-time requirements, and security in mind. The architecture is built around the Data Distribution Service (DDS) standard, which provides a publish-subscribe communication model with Quality of Service (QoS) policies that ensure reliable communication in real-time systems [1]."}),"\n",(0,r.jsx)(i.h3,{id:"client-library-layer",children:"Client Library Layer"}),"\n",(0,r.jsx)(i.p,{children:"The ROS 2 architecture consists of a client library layer (rclcpp for C++ and rclpy for Python) that provides the familiar ROS APIs. This layer abstracts the underlying DDS implementation, allowing developers to write ROS 2 code without directly interacting with DDS [2]."}),"\n",(0,r.jsx)(i.h3,{id:"dds-middleware",children:"DDS Middleware"}),"\n",(0,r.jsx)(i.p,{children:"The Data Distribution Service (DDS) serves as the communication middleware, implementing the publish-subscribe pattern with rich Quality of Service (QoS) controls. DDS provides features such as:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Reliability"}),": Ensures messages are delivered or reports failure"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Durability"}),": Maintains message persistence for late-joining subscribers"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deadline"}),": Guarantees message delivery within specified time constraints"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Liveliness"}),": Monitors the availability of publishers and subscribers"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"History"}),": Controls how many messages to store for delivery [3]"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"domain-ids-and-isolation",children:"Domain IDs and Isolation"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 uses domain IDs to isolate different ROS 2 networks from each other. This is particularly important in humanoid robotics where multiple robots or multiple subsystems might need to operate independently while sharing the same network infrastructure [4]."}),"\n",(0,r.jsx)(i.h2,{id:"core-communication-patterns",children:"Core Communication Patterns"}),"\n",(0,r.jsx)(i.h3,{id:"topics-publish-subscribe",children:"Topics (Publish-Subscribe)"}),"\n",(0,r.jsx)(i.p,{children:"The publish-subscribe pattern is the primary communication mechanism in ROS 2. Publishers send messages to topics without knowledge of subscribers, and subscribers receive messages from topics without knowledge of publishers. This loose coupling is ideal for humanoid robots where different subsystems need to share sensor data or state information without tight dependencies [5]."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"Publisher Node \u2192 Topic \u2192 Subscriber Node\n     \u2193              \u2193           \u2193\n  Sensor Data   \u2192 /sensors \u2192 Processing Node\n"})}),"\n",(0,r.jsx)(i.h3,{id:"services-request-response",children:"Services (Request-Response)"}),"\n",(0,r.jsx)(i.p,{children:"Services provide synchronous request-response communication. A client sends a request and waits for a response from a service server. This pattern is useful for operations requiring immediate feedback, such as requesting robot configuration or querying system status [6]."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"Client Node \u2192 Request \u2192 Service Server\n     \u2193           \u2193            \u2193\n   Query State \u2192 /get_state \u2192 State Manager\n                 \u2190 Response\n                 \u2190 Current State\n"})}),"\n",(0,r.jsx)(i.h3,{id:"actions-goal-based-communication",children:"Actions (Goal-Based Communication)"}),"\n",(0,r.jsx)(i.p,{children:"Actions are designed for long-running tasks with feedback and status updates. They combine the asynchronous nature of topics with the request-response nature of services, making them ideal for humanoid robot behaviors like walking, manipulation, or navigation [7]."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"Client \u2192 Goal \u2192 Action Server\n   \u2193       \u2193         \u2193\n MoveTo \u2192 /move \u2192 Controller\n              \u2192 Feedback (progress)\n              \u2192 Result (completion)\n"})}),"\n",(0,r.jsx)(i.h2,{id:"quality-of-service-qos-policies",children:"Quality of Service (QoS) Policies"}),"\n",(0,r.jsx)(i.p,{children:"QoS policies are a key feature of ROS 2 that allow fine-tuning of communication behavior. For humanoid robots, these policies are crucial for ensuring appropriate communication characteristics for different types of data [8]."}),"\n",(0,r.jsx)(i.h3,{id:"reliability-policy",children:"Reliability Policy"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RELIABLE"}),": Guarantees message delivery (used for critical commands)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"BEST_EFFORT"}),": Attempts delivery without guarantees (used for sensor data where some loss is acceptable)"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"durability-policy",children:"Durability Policy"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"TRANSIENT_LOCAL"}),": Publishers maintain historical data for late-joining subscribers (used for static maps)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"VOLATILE"}),": No historical data maintained (used for real-time sensor data)"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"history-policy",children:"History Policy"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"KEEP_LAST"}),": Maintains a specified number of most recent messages"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"KEEP_ALL"}),": Maintains all messages (limited by system resources)"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 introduces lifecycle nodes that have explicit state management, which is particularly important for humanoid robots where different subsystems need to be initialized, activated, and deactivated in a controlled manner. The lifecycle states include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"UNCONFIGURED"}),": Node created but not configured"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"INACTIVE"}),": Configured but not active"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"ACTIVE"}),": Fully operational"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"FINALIZED"}),": Shutting down [9]"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"parameters-and-configuration",children:"Parameters and Configuration"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 provides a unified parameter system that allows runtime configuration of nodes. Parameters can be set at launch time, changed during runtime, and shared between nodes. This is essential for humanoid robots where operational parameters may need adjustment based on environmental conditions or robot state [10]."}),"\n",(0,r.jsx)(i.h2,{id:"namespaces-and-naming",children:"Namespaces and Naming"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 uses a hierarchical namespace system where nodes, topics, services, and parameters can be organized into logical groups. This is particularly useful in humanoid robots with multiple limbs, sensors, or subsystems that need to be organized logically [11]."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"/robot1/\n\u251c\u2500\u2500 /left_arm/\n\u2502   \u251c\u2500\u2500 /joint_states\n\u2502   \u2514\u2500\u2500 /commands\n\u251c\u2500\u2500 /right_arm/\n\u2502   \u251c\u2500\u2500 /joint_states\n\u2502   \u2514\u2500\u2500 /commands\n\u2514\u2500\u2500 /base/\n    \u251c\u2500\u2500 /odometry\n    \u2514\u2500\u2500 /imu\n"})}),"\n",(0,r.jsx)(i.h2,{id:"time-and-time-sources",children:"Time and Time Sources"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 provides a unified time system that can use different time sources:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"ROS Time"}),": Simulation time (when using sim_time parameter)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"System Time"}),": Real hardware clock"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Custom Time Sources"}),": Specialized time sources for specific applications"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This is crucial for humanoid robots that may operate in simulation or real-world environments [12]."}),"\n",(0,r.jsx)(i.h2,{id:"memory-management-and-performance",children:"Memory Management and Performance"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 uses zero-copy techniques and efficient serialization to minimize memory allocation and copying overhead. This is important for humanoid robots where computational resources may be limited and real-time performance is required [13]."}),"\n",(0,r.jsx)(i.h2,{id:"security-architecture",children:"Security Architecture"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 incorporates security at multiple levels:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transport Security"}),": TLS/SSL encryption for communication"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Access Control"}),": Authentication and authorization"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Message Security"}),": Encryption and signing of messages"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"System Security"}),": Secure launch and configuration [14]"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"integration-with-real-time-systems",children:"Integration with Real-time Systems"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 provides real-time capabilities through:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Real-time scheduling"}),": Support for real-time scheduling policies"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Memory pre-allocation"}),": Avoiding dynamic allocation during real-time execution"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deterministic communication"}),": QoS policies for predictable behavior [15]"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(i.p,{children:'[1] DDS-RMS. (2015). "DDS Real-Time Messaging Specification". Object Management Group.'}),"\n",(0,r.jsxs)(i.p,{children:['[2] ROS 2 Design. (2023). "Client Libraries". Retrieved from ',(0,r.jsx)(i.a,{href:"https://design.ros2.org/articles/client_library_interface.html",children:"https://design.ros2.org/articles/client_library_interface.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[3] ROS 2 Concepts. (2023). "Quality of Service". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Quality-of-Service-Settings.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Quality-of-Service-Settings.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[4] ROS 2 Concepts. (2023). "ROS Domains". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Domain-ID.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Domain-ID.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[5] ROS 2 Concepts. (2023). "Topics". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Topics.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Topics.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[6] ROS 2 Concepts. (2023). "Services". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Services.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Services.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[7] ROS 2 Concepts. (2023). "Actions". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Actions.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Actions.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[8] ROS 2 QoS. (2023). "Quality of Service Implementation". Retrieved from ',(0,r.jsx)(i.a,{href:"https://github.com/ros2/rmw_implementation",children:"https://github.com/ros2/rmw_implementation"})]}),"\n",(0,r.jsxs)(i.p,{children:['[9] ROS 2 Lifecycle. (2023). "Node Lifecycle". Retrieved from ',(0,r.jsx)(i.a,{href:"https://design.ros2.org/articles/node_lifecycle.html",children:"https://design.ros2.org/articles/node_lifecycle.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[10] ROS 2 Parameters. (2023). "Parameters". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Parameters.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Parameters.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[11] ROS 2 Namespaces. (2023). "Namespaces". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Namespaces.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Namespaces.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[12] ROS 2 Time. (2023). "Time". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Time.html",children:"https://docs.ros.org/en/rolling/Concepts/About-Time.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[13] ROS 2 Performance. (2023). "Performance". Retrieved from ',(0,r.jsx)(i.a,{href:"https://design.ros2.org/articles/fast_protobufs.html",children:"https://design.ros2.org/articles/fast_protobufs.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[14] ROS 2 Security. (2023). "Security". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Security/Overview.html",children:"https://docs.ros.org/en/rolling/Tutorials/Security/Overview.html"})]}),"\n",(0,r.jsxs)(i.p,{children:['[15] ROS 2 Tools. (2023). "Command Line Tools". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Releases/Release-Galactic-Geochelone.html#command-line-tools",children:"https://docs.ros.org/en/rolling/Releases/Release-Galactic-Geochelone.html#command-line-tools"})]}),"\n",(0,r.jsxs)(i.p,{children:['[16] ROS 2 Real-time. (2023). "Real-time". Retrieved from ',(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Real-Time-Programming.html",children:"https://docs.ros.org/en/rolling/Tutorials/Real-Time-Programming.html"})]}),"\n",(0,r.jsx)(i.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,r.jsx)(i.p,{children:"For related concepts, see:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/Physical-AI-Robotics-Book/docs/ros2/implementation",children:"ROS 2 Implementation"})," for practical setup of the theoretical concepts"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/Physical-AI-Robotics-Book/docs/digital-twin/simulation-basics",children:"Digital Twin Simulation"})," for simulation theory integration"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/Physical-AI-Robotics-Book/docs/nvidia-isaac/core-concepts",children:"NVIDIA Isaac"})," for advanced platform architecture concepts"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/Physical-AI-Robotics-Book/docs/vla-systems/architecture",children:"Vision-Language-Action Systems"})," for AI system architecture"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>l});var n=s(6540);const r={},t=n.createContext(r);function o(e){const i=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(t.Provider,{value:i},e.children)}}}]);